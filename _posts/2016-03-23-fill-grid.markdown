---
layout: 	post
title: 		"蓝桥杯 方格填数 DFS"
date:		2016-03-23 20:28 +0800
share:      http://ww2.sinaimg.cn/mw690/da914f1fgw1f272gvetlqj206b05amx2.jpg
---

#### 题目描述：如下的10个格子（见下图），填入0~9的数字。要求：连续的**两个数字**不能相邻。

##### （左右、上下、对角都算相邻）

##### 求一共有多少种可能的填数方案？

![题目描述](http://ww2.sinaimg.cn/mw690/da914f1fgw1f272gvetlqj206b05amx2.jpg)

#### **答案**：1580

##### **解题思想**：很直观的填数题目，直观感觉用搜索就可以了，一个DFS解决一切，到达临界状态（满足条件的填入数字，一直搜索到了最后一个格子，这个时候表示十个格子已经填满了）的时候记录下数量，最后输出就可以了。

<!--break-->

##### **实现技巧**：题中的图形是一个3*4的方格阵，挖去了第一个和最后一个格子得到的，但是这并不影响我们的深度搜索，直接从左上到右下进行一维深度搜索，递归调用不产生分支，对格子的编号从2到11，不过这样一来不方便判断八个方向的相邻数是否符合条件，需要做坐标的转换，每次dfs一个格子的时候遍历0～9（笔者使用了1～10，替换0～9，这样做的好处是不会让想要填入0的时候跟数组初始化时的-1产生冲突）10个数，确定是否可以填入当前格，可以填入就填入，然后dfs下一个格子，知道搜索到了第12个格子（显然是不存在的）这个时候表明这一条递归链的情况是符合的，计数，然后返回就可以了。以上时本题dfs的大题思想。

##### po上自己的代码

```cpp
#include <stdio.h>
#include <iostream>
#include <math.h>
using namespace std;
#define R 3 // 行
#define C 4 // 列

int a[R + 1][C + 1]; // 主数据区间
bool vis[11] = {0};		// 访问标记
int vector[8][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1},
 {1, 1}, {1, -1}, {-1, 1}, {-1, -1} };		// 方向向量

bool isBound/*判断坐标是否合法*/(int i, int j) {
    if (i == 1 && j == 1) return false;
    if (i == R && j == C) return false;
    if (i < 1 || i > R || j < 1 || j > C) return false;
    return true;
}

int cnt = 0;	/*计数*/

void dfs(int i) {	
    if (i == R*C) /*到达这里就说明填完了*/ {
        cnt++;
        return;
    }
    
    int x = (i - 1)/C + 1;	//一维下标转二维坐标
    int y = (i - 1)%C + 1;	//同上
    
    /* 循环便利所有要填入的数 */
    for (int num = 1; num <= (R*C-2); num++) {
        if (vis[num]) continue; // 访问过自然不用管，这题不允许重复（可重复的话时间复杂度会加大，编程倒是方便了，直接去掉这一句就行）

        int idx = -1;
        // 迭代八个方向
        while(++idx < 8) {
            int xx = x + vector[idx][0];
            int yy = y + vector[idx][1];
            
            if(!isBound(xx, yy)) continue;
            if (abs(a[xx][yy] - num) == 1) break;
        }
        if (idx != 8) /* 中途退出 */ continue;
        
        a[x][y] = num;
        vis[num] = 1;
        dfs(i + 1);
        a[x][y] = -1;
        vis[num] = 0;
    }
}

int main () {
    memset(a, -1, sizeof(a)); // 使用-1清空二维数组（memset的第二个参数通常－1，0）
    dfs(2);
    cout<<cnt<<endl;
}
```

##### **小结**：深度搜索的实现不算复杂，这里并不涉及记忆化，剪枝等技巧，但是也有一个很容易遗漏的地方，那就是当要求我们复合一定的附加条件的时候，要注意递归返回后状态的恢复，否则在这里数组的**a**中在处理过的元素被用于判定就会造成逻辑错误，此题的正确答案应该是1580，但是遗漏掉备注出来的重要的一行可能就会得到*62*，这是因为在某次dfs中填入的数据值，影响到了其他dfs判断是否有相邻的数据值被填入，直接导致了可能的情况缩水。这其中的原理类似于用于标记格子是否访问的数组vis，在搜索前要对其置入访问状态，搜索完成后撤销访问状态。
